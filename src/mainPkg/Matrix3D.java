package mainPkg;

public class Matrix3D
{
    // Class Fields.
    private double m[][];

    // Class Methods.

    // Default Constructor.
    Matrix3D()
    {
        m = new double[4][4];
        Clear();
    }

    // Set an initial placement and size of cube.
    public void Clear()
    {
        m[0][0] = 1;
        m[0][1] = 0;
        m[0][2] = 0;
        m[0][3] = 0;
        m[1][0] = 0;
        m[1][1] = 1;
        m[1][2] = 0;
        m[1][3] = 0;
        m[2][0] = 0;
        m[2][1] = 0;
        m[2][2] = 1;
        m[2][3] = 0;
        m[3][0] = 0;
        m[3][1] = 0;
        m[3][2] = 0;
        m[3][3] = 1;
    }

    // Accessor functions.
    double c00()
    {
        return m[0][0];
    }

    double c01()
    {
        return m[0][1];
    }

    double c02()
    {
        return m[0][2];
    }

    double c03()
    {
        return m[0][3];
    }

    double c10()
    {
        return m[1][0];
    }

    double c11()
    {
        return m[1][1];
    }

    double c12()
    {
        return m[1][2];
    }

    double c13()
    {
        return m[1][3];
    }

    double c20()
    {
        return m[2][0];
    }

    double c21()
    {
        return m[2][1];
    }

    double c22()
    {
        return m[2][2];
    }

    double c23()
    {
        return m[2][3];
    }


    void Translate(double tx, double ty, double tz)
    {
        double a[][] = new double[4][4];
        double b[][] = new double[4][4];

        // a is the new transform matrix component.
        a[0][0] = 1;
        a[0][3] = tx;
        a[1][1] = 1;
        a[1][3] = ty;
        a[2][2] = 1;
        a[2][3] = tz;
        a[3][3] = 1;

        // b is the original values of the old transform matrix.
        b[0][0] = m[0][0];
        b[0][1] = m[0][1];
        b[0][2] = m[0][2];
        b[0][3] = m[0][3];
        b[1][0] = m[1][0];
        b[1][1] = m[1][1];
        b[1][2] = m[1][2];
        b[1][3] = m[1][3];
        b[2][0] = m[2][0];
        b[2][1] = m[2][1];
        b[2][2] = m[2][2];
        b[2][3] = m[2][3];
        b[3][0] = m[3][0];
        b[3][1] = m[3][1];
        b[3][2] = m[3][2];
        b[3][3] = m[3][3];

        // Compute the matrix multiplication, m = a X b
        m[0][0] = a[0][0]*b[0][0] + a[0][1]*b[1][0] + a[0][2]*b[2][0] + a[0][3]*b[3][0];
        m[0][1] = a[0][0]*b[0][1] + a[0][1]*b[1][1] + a[0][2]*b[2][1] + a[0][3]*b[3][1];
        m[0][2] = a[0][0]*b[0][2] + a[0][1]*b[1][2] + a[0][2]*b[2][2] + a[0][3]*b[3][2];
        m[0][3] = a[0][0]*b[0][3] + a[0][1]*b[1][3] + a[0][2]*b[2][3] + a[0][3]*b[3][3];

        m[1][0] = a[1][0]*b[0][0] + a[1][1]*b[1][0] + a[1][2]*b[2][0] + a[1][3]*b[3][0];
        m[1][1] = a[1][0]*b[0][1] + a[1][1]*b[1][1] + a[1][2]*b[2][1] + a[1][3]*b[3][1];
        m[1][2] = a[1][0]*b[0][2] + a[1][1]*b[1][2] + a[1][2]*b[2][2] + a[1][3]*b[3][2];
        m[1][3] = a[1][0]*b[0][3] + a[1][1]*b[1][3] + a[1][2]*b[2][3] + a[1][3]*b[3][3];

        m[2][0] = a[2][0]*b[0][0] + a[2][1]*b[1][0] + a[2][2]*b[2][0] + a[2][3]*b[3][0];
        m[2][1] = a[2][0]*b[0][1] + a[2][1]*b[1][1] + a[2][2]*b[2][1] + a[2][3]*b[3][1];
        m[2][2] = a[2][0]*b[0][2] + a[2][1]*b[1][2] + a[2][2]*b[2][2] + a[2][3]*b[3][2];
        m[2][3] = a[2][0]*b[0][3] + a[2][1]*b[1][3] + a[2][2]*b[2][3] + a[2][3]*b[3][3];

        m[3][0] = a[3][0]*b[0][0] + a[3][1]*b[1][0] + a[3][2]*b[2][0] + a[3][3]*b[3][0];
        m[3][1] = a[3][0]*b[0][1] + a[3][1]*b[1][1] + a[3][2]*b[2][1] + a[3][3]*b[3][1];
        m[3][2] = a[3][0]*b[0][2] + a[3][1]*b[1][2] + a[3][2]*b[2][2] + a[3][3]*b[3][2];
        m[3][3] = a[3][0]*b[0][3] + a[3][1]*b[1][3] + a[3][2]*b[2][3] + a[3][3]*b[3][3];
    }

    // Scale equally on all 3 axes.
    void Scale(double s)
    {
        Scale(s,s,s);
    }

    // Scale by individual x,y,z factors.
    void Scale(double sx, double sy, double sz)
    {
        double a[][] = new double[4][4];
        double b[][] = new double[4][4];

        // a is the new transform matrix component.
        a[0][0] = sx;
        a[1][1] = sy;
        a[2][2] = sz;
        a[3][3] = 1;

        // b is the original values of the old transform matrix.
        b[0][0] = m[0][0];
        b[0][1] = m[0][1];
        b[0][2] = m[0][2];
        b[0][3] = m[0][3];
        b[1][0] = m[1][0];
        b[1][1] = m[1][1];
        b[1][2] = m[1][2];
        b[1][3] = m[1][3];
        b[2][0] = m[2][0];
        b[2][1] = m[2][1];
        b[2][2] = m[2][2];
        b[2][3] = m[2][3];
        b[3][0] = m[3][0];
        b[3][1] = m[3][1];
        b[3][2] = m[3][2];
        b[3][3] = m[3][3];

        // Compute the matrix multiplication, m = a X b
        m[0][0] = a[0][0]*b[0][0] + a[0][1]*b[1][0] + a[0][2]*b[2][0] + a[0][3]*b[3][0];
        m[0][1] = a[0][0]*b[0][1] + a[0][1]*b[1][1] + a[0][2]*b[2][1] + a[0][3]*b[3][1];
        m[0][2] = a[0][0]*b[0][2] + a[0][1]*b[1][2] + a[0][2]*b[2][2] + a[0][3]*b[3][2];
        m[0][3] = a[0][0]*b[0][3] + a[0][1]*b[1][3] + a[0][2]*b[2][3] + a[0][3]*b[3][3];

        m[1][0] = a[1][0]*b[0][0] + a[1][1]*b[1][0] + a[1][2]*b[2][0] + a[1][3]*b[3][0];
        m[1][1] = a[1][0]*b[0][1] + a[1][1]*b[1][1] + a[1][2]*b[2][1] + a[1][3]*b[3][1];
        m[1][2] = a[1][0]*b[0][2] + a[1][1]*b[1][2] + a[1][2]*b[2][2] + a[1][3]*b[3][2];
        m[1][3] = a[1][0]*b[0][3] + a[1][1]*b[1][3] + a[1][2]*b[2][3] + a[1][3]*b[3][3];

        m[2][0] = a[2][0]*b[0][0] + a[2][1]*b[1][0] + a[2][2]*b[2][0] + a[2][3]*b[3][0];
        m[2][1] = a[2][0]*b[0][1] + a[2][1]*b[1][1] + a[2][2]*b[2][1] + a[2][3]*b[3][1];
        m[2][2] = a[2][0]*b[0][2] + a[2][1]*b[1][2] + a[2][2]*b[2][2] + a[2][3]*b[3][2];
        m[2][3] = a[2][0]*b[0][3] + a[2][1]*b[1][3] + a[2][2]*b[2][3] + a[2][3]*b[3][3];

        m[3][0] = a[3][0]*b[0][0] + a[3][1]*b[1][0] + a[3][2]*b[2][0] + a[3][3]*b[3][0];
        m[3][1] = a[3][0]*b[0][1] + a[3][1]*b[1][1] + a[3][2]*b[2][1] + a[3][3]*b[3][1];
        m[3][2] = a[3][0]*b[0][2] + a[3][1]*b[1][2] + a[3][2]*b[2][2] + a[3][3]*b[3][2];
        m[3][3] = a[3][0]*b[0][3] + a[3][1]*b[1][3] + a[3][2]*b[2][3] + a[3][3]*b[3][3];
    }

    // Rotate about the x axis, theta in degrees.
    void RotateX(double theta)
    {
        double a[][] = new double[4][4];
        double b[][] = new double[4][4];

        // a is the new transform matrix component.
        a[0][0] = 1;
        a[1][1] = Math.cos(theta*Math.PI/180);
        a[1][2] = -Math.sin(theta*Math.PI/180);
        a[2][1] = Math.sin(theta*Math.PI/180);
        a[2][2] = Math.cos(theta*Math.PI/180);
        a[3][3] = 1;

        // b is the original values of the old transform matrix.
        b[0][0] = m[0][0];
        b[0][1] = m[0][1];
        b[0][2] = m[0][2];
        b[0][3] = m[0][3];
        b[1][0] = m[1][0];
        b[1][1] = m[1][1];
        b[1][2] = m[1][2];
        b[1][3] = m[1][3];
        b[2][0] = m[2][0];
        b[2][1] = m[2][1];
        b[2][2] = m[2][2];
        b[2][3] = m[2][3];
        b[3][0] = m[3][0];
        b[3][1] = m[3][1];
        b[3][2] = m[3][2];
        b[3][3] = m[3][3];

        // Compute the matrix multiplication, m = a X b
        m[0][0] = a[0][0]*b[0][0] + a[0][1]*b[1][0] + a[0][2]*b[2][0] + a[0][3]*b[3][0];
        m[0][1] = a[0][0]*b[0][1] + a[0][1]*b[1][1] + a[0][2]*b[2][1] + a[0][3]*b[3][1];
        m[0][2] = a[0][0]*b[0][2] + a[0][1]*b[1][2] + a[0][2]*b[2][2] + a[0][3]*b[3][2];
        m[0][3] = a[0][0]*b[0][3] + a[0][1]*b[1][3] + a[0][2]*b[2][3] + a[0][3]*b[3][3];

        m[1][0] = a[1][0]*b[0][0] + a[1][1]*b[1][0] + a[1][2]*b[2][0] + a[1][3]*b[3][0];
        m[1][1] = a[1][0]*b[0][1] + a[1][1]*b[1][1] + a[1][2]*b[2][1] + a[1][3]*b[3][1];
        m[1][2] = a[1][0]*b[0][2] + a[1][1]*b[1][2] + a[1][2]*b[2][2] + a[1][3]*b[3][2];
        m[1][3] = a[1][0]*b[0][3] + a[1][1]*b[1][3] + a[1][2]*b[2][3] + a[1][3]*b[3][3];

        m[2][0] = a[2][0]*b[0][0] + a[2][1]*b[1][0] + a[2][2]*b[2][0] + a[2][3]*b[3][0];
        m[2][1] = a[2][0]*b[0][1] + a[2][1]*b[1][1] + a[2][2]*b[2][1] + a[2][3]*b[3][1];
        m[2][2] = a[2][0]*b[0][2] + a[2][1]*b[1][2] + a[2][2]*b[2][2] + a[2][3]*b[3][2];
        m[2][3] = a[2][0]*b[0][3] + a[2][1]*b[1][3] + a[2][2]*b[2][3] + a[2][3]*b[3][3];

        m[3][0] = a[3][0]*b[0][0] + a[3][1]*b[1][0] + a[3][2]*b[2][0] + a[3][3]*b[3][0];
        m[3][1] = a[3][0]*b[0][1] + a[3][1]*b[1][1] + a[3][2]*b[2][1] + a[3][3]*b[3][1];
        m[3][2] = a[3][0]*b[0][2] + a[3][1]*b[1][2] + a[3][2]*b[2][2] + a[3][3]*b[3][2];
        m[3][3] = a[3][0]*b[0][3] + a[3][1]*b[1][3] + a[3][2]*b[2][3] + a[3][3]*b[3][3];
    }

    // Rotate about the y axis, theta in degrees.
    void RotateY(double theta)
    {
        double a[][] = new double[4][4];
        double b[][] = new double[4][4];

        // a is the new transform matrix component.
        a[0][0] = Math.cos(theta*Math.PI/180);
        a[0][2] = Math.sin(theta*Math.PI/180);
        a[1][1] = 1;
        a[2][0] = -Math.sin(theta*Math.PI/180);
        a[2][2] = Math.cos(theta*Math.PI/180);
        a[3][3] = 1;

        // b is the original values of the old transform matrix.
        b[0][0] = m[0][0];
        b[0][1] = m[0][1];
        b[0][2] = m[0][2];
        b[0][3] = m[0][3];
        b[1][0] = m[1][0];
        b[1][1] = m[1][1];
        b[1][2] = m[1][2];
        b[1][3] = m[1][3];
        b[2][0] = m[2][0];
        b[2][1] = m[2][1];
        b[2][2] = m[2][2];
        b[2][3] = m[2][3];
        b[3][0] = m[3][0];
        b[3][1] = m[3][1];
        b[3][2] = m[3][2];
        b[3][3] = m[3][3];

        // Compute the matrix multiplication, m = a X b
        m[0][0] = a[0][0]*b[0][0] + a[0][1]*b[1][0] + a[0][2]*b[2][0] + a[0][3]*b[3][0];
        m[0][1] = a[0][0]*b[0][1] + a[0][1]*b[1][1] + a[0][2]*b[2][1] + a[0][3]*b[3][1];
        m[0][2] = a[0][0]*b[0][2] + a[0][1]*b[1][2] + a[0][2]*b[2][2] + a[0][3]*b[3][2];
        m[0][3] = a[0][0]*b[0][3] + a[0][1]*b[1][3] + a[0][2]*b[2][3] + a[0][3]*b[3][3];

        m[1][0] = a[1][0]*b[0][0] + a[1][1]*b[1][0] + a[1][2]*b[2][0] + a[1][3]*b[3][0];
        m[1][1] = a[1][0]*b[0][1] + a[1][1]*b[1][1] + a[1][2]*b[2][1] + a[1][3]*b[3][1];
        m[1][2] = a[1][0]*b[0][2] + a[1][1]*b[1][2] + a[1][2]*b[2][2] + a[1][3]*b[3][2];
        m[1][3] = a[1][0]*b[0][3] + a[1][1]*b[1][3] + a[1][2]*b[2][3] + a[1][3]*b[3][3];

        m[2][0] = a[2][0]*b[0][0] + a[2][1]*b[1][0] + a[2][2]*b[2][0] + a[2][3]*b[3][0];
        m[2][1] = a[2][0]*b[0][1] + a[2][1]*b[1][1] + a[2][2]*b[2][1] + a[2][3]*b[3][1];
        m[2][2] = a[2][0]*b[0][2] + a[2][1]*b[1][2] + a[2][2]*b[2][2] + a[2][3]*b[3][2];
        m[2][3] = a[2][0]*b[0][3] + a[2][1]*b[1][3] + a[2][2]*b[2][3] + a[2][3]*b[3][3];

        m[3][0] = a[3][0]*b[0][0] + a[3][1]*b[1][0] + a[3][2]*b[2][0] + a[3][3]*b[3][0];
        m[3][1] = a[3][0]*b[0][1] + a[3][1]*b[1][1] + a[3][2]*b[2][1] + a[3][3]*b[3][1];
        m[3][2] = a[3][0]*b[0][2] + a[3][1]*b[1][2] + a[3][2]*b[2][2] + a[3][3]*b[3][2];
        m[3][3] = a[3][0]*b[0][3] + a[3][1]*b[1][3] + a[3][2]*b[2][3] + a[3][3]*b[3][3];
    }

    // Rotate about the z axis, theta in degrees.
    void RotateZ(double theta)
    {
        double a[][] = new double[4][4];
        double b[][] = new double[4][4];

        // a is the new transform matrix component.
        a[0][0] = Math.cos(theta*Math.PI/180);
        a[0][1] = -Math.sin(theta*Math.PI/180);
        a[1][0] = Math.sin(theta*Math.PI/180);
        a[1][1] = Math.cos(theta*Math.PI/180);
        a[2][2] = 1;
        a[3][3] = 1;

        // b is the original values of the old transform matrix.
        b[0][0] = m[0][0];
        b[0][1] = m[0][1];
        b[0][2] = m[0][2];
        b[0][3] = m[0][3];
        b[1][0] = m[1][0];
        b[1][1] = m[1][1];
        b[1][2] = m[1][2];
        b[1][3] = m[1][3];
        b[2][0] = m[2][0];
        b[2][1] = m[2][1];
        b[2][2] = m[2][2];
        b[2][3] = m[2][3];
        b[3][0] = m[3][0];
        b[3][1] = m[3][1];
        b[3][2] = m[3][2];
        b[3][3] = m[3][3];

        // Compute matrix multiplication, m = a X b
        m[0][0] = a[0][0]*b[0][0] + a[0][1]*b[1][0] + a[0][2]*b[2][0] + a[0][3]*b[3][0];
        m[0][1] = a[0][0]*b[0][1] + a[0][1]*b[1][1] + a[0][2]*b[2][1] + a[0][3]*b[3][1];
        m[0][2] = a[0][0]*b[0][2] + a[0][1]*b[1][2] + a[0][2]*b[2][2] + a[0][3]*b[3][2];
        m[0][3] = a[0][0]*b[0][3] + a[0][1]*b[1][3] + a[0][2]*b[2][3] + a[0][3]*b[3][3];

        m[1][0] = a[1][0]*b[0][0] + a[1][1]*b[1][0] + a[1][2]*b[2][0] + a[1][3]*b[3][0];
        m[1][1] = a[1][0]*b[0][1] + a[1][1]*b[1][1] + a[1][2]*b[2][1] + a[1][3]*b[3][1];
        m[1][2] = a[1][0]*b[0][2] + a[1][1]*b[1][2] + a[1][2]*b[2][2] + a[1][3]*b[3][2];
        m[1][3] = a[1][0]*b[0][3] + a[1][1]*b[1][3] + a[1][2]*b[2][3] + a[1][3]*b[3][3];

        m[2][0] = a[2][0]*b[0][0] + a[2][1]*b[1][0] + a[2][2]*b[2][0] + a[2][3]*b[3][0];
        m[2][1] = a[2][0]*b[0][1] + a[2][1]*b[1][1] + a[2][2]*b[2][1] + a[2][3]*b[3][1];
        m[2][2] = a[2][0]*b[0][2] + a[2][1]*b[1][2] + a[2][2]*b[2][2] + a[2][3]*b[3][2];
        m[2][3] = a[2][0]*b[0][3] + a[2][1]*b[1][3] + a[2][2]*b[2][3] + a[2][3]*b[3][3];

        m[3][0] = a[3][0]*b[0][0] + a[3][1]*b[1][0] + a[3][2]*b[2][0] + a[3][3]*b[3][0];
        m[3][1] = a[3][0]*b[0][1] + a[3][1]*b[1][1] + a[3][2]*b[2][1] + a[3][3]*b[3][1];
        m[3][2] = a[3][0]*b[0][2] + a[3][1]*b[1][2] + a[3][2]*b[2][2] + a[3][3]*b[3][2];
        m[3][3] = a[3][0]*b[0][3] + a[3][1]*b[1][3] + a[3][2]*b[2][3] + a[3][3]*b[3][3];
    }

    // Rotate by individual x, y, z factors on each axis. Theta in degrees.
    void Rotate(double thetaX, double thetaY, double thetaZ)
    {
        RotateX(thetaX);
        RotateY(thetaY);
        RotateZ(thetaZ);
    }

    // Output for debugging.
    void Print()
    {
        System.out.println("Matrix3D Output:");
        System.out.println("["+m[0][0]+"]\t["+m[0][1]+"]\t["+m[0][2]+"]\t["+m[0][3]+"]");
        System.out.println("["+m[1][0]+"]\t["+m[1][1]+"]\t["+m[1][2]+"]\t["+m[1][3]+"]");
        System.out.println("["+m[2][0]+"]\t["+m[2][1]+"]\t["+m[2][2]+"]\t["+m[2][3]+"]");
        System.out.println("["+m[3][0]+"]\t["+m[3][1]+"]\t["+m[3][2]+"]\t["+m[3][3]+"]");
    }
}
